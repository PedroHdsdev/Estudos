# -*- coding: utf-8 -*-
"""AULA RECURSIVIDADE

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dEPt-2yZ7aaKo1WTLcVJyaGz0cFaqxqv

**FATORIAL**
"""

def fatorial(n):
    if n == 0:
        return 1 #RESULTADO
    else:
        return n * fatorial(n-1) #CHAMADO RECURSIVO - RETORNO DE UMA OPERAÇÃO (RECURSIVIDADE)

x  = int(input ("Digite um número para calcular seu Fatorial:"))
resultado = fatorial(x)
print("O Fatorial de %d é %d " %(x,resultado))

#x/y
import numpy as np


def divisao(x,y):
  if y==0:
    return print("Não existe divisão por zero")
  else:
    return x/y

r=np.double(input("Digite o numerador: "))
e=np.double(input("Digite o denominador: "))
resultado= divisao(r,e)
print("A resposta da divisão é: ",resultado)

import numpy as np


def operacao(S,X):
  if S==0 and X==0:
    return 0
  else:
    return 575*(S+X)


r=int(input("Digite o primeiro valor: "))
e=int(input("Digite o segundo valor: "))
resultado= operacao(r,e)
print("A resposta da operação é: ",resultado)

import numpy as np
#x/y
def divisao(x,y):
  if y==0:
    return print("Não existe divisão por zero!")
  else:
    return (x+y)**2

r=np.double(input("Digite o numerador: "))
e=np.double(input("Digite o denominador: "))
resultado=  divisao(r,e)
print("O resultado é: ",resultado)

"""**FIBONACCI**"""

def fibonacci(num):
  if num <=1:
    return num
  else:
    return fibonacci(num-1) + fibonacci(num-2)

x  = int(input ("Digite um número para calcular seu Fibonacci"))
resultado = fibonacci(x-1)
print("O Fibonacci de %d é %d" %(x,resultado))

#fórmula física

import matplotlib.pyplot as plt
import numpy as np


def aceleracao(vf,vi,tf,ti):
  if (tf-ti)==0:
    return print("Não existe divisão por zero")
  else:
    return print("O resultado da aceleração é: ",(vf-vi)/(tf-ti))

vf = int(input ("Digite vf: "))
vi = int(input ("Digite vi: "))
tf = int(input ("Digite tf: "))
ti = int(input ("Digite ti: "))

resultado = aceleracao(vf,vi,tf,ti)

#plotagem da aceleração

plt.plot(np.linspace(vf,vi),np.linspace(tf,ti))

"""**COMPARATIVO RECURSIVO X ITERATIVO**

**RECURSIVO**
"""

def fatorial_recursivo(n):
    if n == 0:
      return 1
    else:
      return n * fatorial_recursivo(n - 1)


x = int(input ("Digite um número para calcular o seu FATORIAL."))
resultado = fatorial_recursivo(x)
print("O fatorial de %d é %d" % (x,resultado))

"""**ITERATIVO**"""

def fatorial_iterativo(n):
  fatorial = 1
  while (n):
    print("erro")
    fatorial *= n
    n -= 1
  return fatorial



x = int(input ("Digite um número para calcular o seu FATORIAL."))
resultado = fatorial_iterativo(x)
print("O fatorial de %d é %d" % (x,resultado))

"""**LISTAS**"""

tabnum=[5,7,10, 8, 8 , 8, 45,12,63,29,17,12,45,29,52.1,69.58]
print(tabnum[1]*tabnum[2])

tabfrutas_peso=[["mamão",2], ["banana",10],["uva",1], ["morango",5]]
#print(tabfrutas_peso)

tabnomes = [["Milena"],["Kelly"], ["Maria"], ["José"], ["Cláudio"], ["Milena"], ["Milena"]]
#print(tabnomes)

# count -  retorna quantas vezes o elemento ["Kelly"] ocorre na lista tabnomes (por exemplo)

#tabnomes.count(["Milena"])

tabnum.count(29)

# index -  retorna o índice da primeira ocorrência do elemento ["Pedro"] na lista tabnomes (por exemplo). Se não existe x retorna ValueError

tabnum.index(8)

# index(["Milena"],0) -  retorna o índice da primeira ocorrência do elemento ["Milena"] a partir do elememento 0 na lista numeros(por exemplo).
#Se não existe ["Milena"] após determinada posição, aparecerá: "ValueError: ["Milena"] is not in list"


tabnomes.index(["Milena"],0)

# index(5,0) -  retorna o índice da primeira ocorrência do elemento 5 a partir do elememento 0 na lista numeros(por exemplo).
#Se não existe 5 após determinada posição, aparecerá: "ValueError: 5 is not in list"



numeros = [1,2,5,3,6,2,52,22,2,1,5,5,5,5,5,2]

numeros.index(5,9)

# index(5,3,11) -  retorna o índice da primeira ocorrência do elemento 5 a partir do elememento 3 na lista numeros até 10 (por exemplo).
#Se não existe 5 após determinada posição, aparecerá: "ValueError: 5 is not in list"



numeros = [1,2,5,3,6,2,52,22,2,1,5,5,5,5,5,2]

numeros.index(5,3,11)

"""**ALGORITMO DE BUSCA SEQUENCIAL**"""

# busca do elemento x numa lista a de n elementos, devolvendo –1 se não o encontrou
# ou o índice do primeiro elemento igual a x encontrado.

lista=[1,2,5,7,9,21,50,200, 1520,52, 1,21,23,2,2,2, 450, 85, 74, 15, 987]

def busca_sequencial(lista, x):
 for i in range(len(lista)):
  if lista[i] == x: return i  # encontrou
 return -1 # não encontrou



busca_sequencial(lista,9870)

chave = 45
lista = [20, 5, 15, 24, 67, 45, 1, 76, 21, 11]

def buscaSequencial(lista, chave):
 n = len(lista) #tamanho da lista que estou explorando
 for i in range(n):
  if lista[i] == chave:
   return i

 return -1

buscaSequencial(lista, 67)
#buscaSequencial(lista, 210)

"""**ALGORITMO DE BUSCA BINÁRIA ORDENADA**"""

lista=[1,2,3,8,9,41,58,25,98,100,121,300]

def buscaBinária(lista, chave):
 pos_ini = 0
 pos_fim = len(lista) - 1

 while pos_ini <= pos_fim:
  pos_meio = (pos_ini + pos_fim) // 2
  print(pos_meio)
  if lista[pos_meio] == chave:
     return pos_meio
  if lista[pos_meio] > chave:
   pos_fim = pos_meio - 1
  if lista[pos_meio] < chave:
   pos_ini = pos_meio + 1

 return -1

buscaBinária(lista,2)

"""**EXERCÍCIO**"""

lista = [1,2,3,5,1,5,9,1,52,12,1,2,3,4,1,1,1,1,1,1,1,1,11,1,1,1]


def busca_seq(lista, x):
 for i in range(len(lista)):
  if lista[i] == x: print(i)
 return -1 # não encontrou


busca_seq(lista, 1)

"""**ORIENTAÇÃO A OBJETOS**"""

# Definindo uma classe chamada "Carro"
class Carro:
    # Atributo da classe
    cor1 = "vermelho"
    cor2 = "azul"
    cor3 = "verde"
    cor4 = "preto"
    cor5 = "branco"
    cor6 = "cinza"
    cor7 = "lilás"
    cor8 = "amarelo"
    modelo = "HB20"
    modelo1 = "Mercedes"
    modelo2 = "BMW"
    ano = "2023"
    quilometragem = "0Km"
    velocidade_máxima_HB20= "120 Km/h"
    velocidade_máxima_Mercedes= "240 Km/h"
    velocidade_máxima_BMW= "180 Km/h"

    # Método da classe
    def buzinar(self):
        return "BEEP BEEP!"

    def ligar(self):
        return "Carro está ligado!"

    def desligar(self):
        return "Carro está desligado!"

    def frear(self):
        return "Carro está desligado!"


# Criando um objeto da classe "Carro"
meu_carro = Carro()



# Acessando o atributo da classe
print(f"A cor do carro é {meu_carro.cor6}")
# Acessando o atributo da classe
print(f"A modelo do carro é {meu_carro.modelo2}, tem a cor {meu_carro.cor3}, tem a velocidade máxima de {meu_carro.velocidade_máxima_BMW}, e é {meu_carro.quilometragem}.")


# Chamando o método da classe
som_da_buzina = meu_carro.buzinar()
print(som_da_buzina)

# Chamando o método da classe
ligar = meu_carro.ligar()
print(ligar)


# Chamando o método da classe
desligar = meu_carro.desligar()
print(desligar)

"""class Carro:: Define uma classe chamada "Carro". A classe tem um atributo chamado "cor" e um método chamado "buzinar".

cor = "vermelho": Define o atributo da classe "cor" com o valor "vermelho". Todos os objetos da classe terão essa cor inicialmente.

def buzinar(self):: Define um método chamado "buzinar" que pertence à classe "Carro". O self é uma referência ao objeto em si, que é passada automaticamente quando o método é chamado.

return "BEEP BEEP!": Dentro do método "buzinar", retornamos uma mensagem que representa o som da buzina.

meu_carro = Carro(): Criamos um objeto da classe "Carro" chamado "meu_carro".

print(f"A cor do carro é {meu_carro.cor}"): Acessamos o atributo da classe "cor" do objeto "meu_carro" e o imprimimos.

som_da_buzina = meu_carro.buzinar(): Chamamos o método "buzinar" no objeto "meu_carro" e armazenamos o som da buzina em uma variável chamada "som_da_buzina".

print(som_da_buzina): Imprimimos o som da buzina que foi retornado pelo método "buzinar".
"""

# Definindo uma classe chamada "Pessoa"
class Pessoa:
    # O construtor da classe define os atributos iniciais
    def __init__(self, nome, idade, escolaridade, renda, gênero):
        self.nome = nome  # Atributo "nome"
        self.idade = idade  # Atributo "idade"
        self.escolaridade = escolaridade
        self.renda = renda
        self.gênero = gênero

    # Um método da classe para cumprimentar
    def cumprimentar(self):
        return f"Olá, meu nome é {self.nome} e tenho {self.idade} anos."

# Criando um objeto da classe "Pessoa"
pessoa1 = Pessoa("João", 30, 25, "Superior Completo", "masculino")

# Acessando os atributos do objeto
print(f"Nome: {pessoa1.nome}")
print(f"Idade: {pessoa1.idade}")

# Chamando o método da classe
mensagem_de_cumprimento = pessoa1.cumprimentar()
print(mensagem_de_cumprimento)

"""class Pessoa:: Define uma classe chamada "Pessoa". Uma classe é um modelo para criar objetos.

def __init__(self, nome, idade):: Define um método especial chamado "init", que é o construtor da classe. Ele inicializa os atributos da classe. O self é uma referência ao objeto em si, que é passada automaticamente quando o método é chamado.

self.nome = nome e self.idade = idade: Dentro do construtor, atribuímos os valores passados como argumentos aos atributos nome e idade do objeto.

def cumprimentar(self):: Define um método chamado "cumprimentar" que pertence à classe "Pessoa". Este método retorna uma mensagem de cumprimento.

return f"Olá, meu nome é {self.nome} e tenho {self.idade} anos.": Dentro do método "cumprimentar", retornamos uma mensagem usando os valores dos atributos nome e idade.

pessoa1 = Pessoa("João", 30): Criamos um objeto da classe "Pessoa" chamado "pessoa1" com os valores "João" e 30 para os atributos nome e idade.

print(f"Nome: {pessoa1.nome}") e print(f"Idade: {pessoa1.idade}"): Acessamos os atributos nome e idade do objeto "pessoa1" e os imprimimos.

mensagem_de_cumprimento = pessoa1.cumprimentar(): Chamamos o método "cumprimentar" no objeto "pessoa1" e armazenamos a mensagem retornada em uma variável chamada "mensagem_de_cumprimento".

print(mensagem_de_cumprimento): Imprimimos a mensagem de cumprimento que foi retornada pelo método "cumprimentar".
"""



#Método Construtor

class professora:
  def __init__(self):
    self.nome= 'Kelly Maciel Costa'
    print('A professora da disciplina é '+self.nome)


x=professora() #instanciando a classe

#Método Construtor com parâmetros

class cores:
  def __init__(self,nome, cor):
    self.nome=nome #definição de variáveis
    self.cor=cor
    print('A cor que '+self.nome+' prefere é '+self.cor +'!')

#definindo variáveis
a= input('Digite o seu nome: ')
b= input('Digite a sua cor: ')
cor=cores(a, b)

#utilização _repr_ e None

class Complex:

    def __init__(self, real=None, imag=None):
       self.real = real
       self.imag = imag


    def __repr__(self):
       return 'Rational(%s, %s)' % (self.real, self.imag)


t = Complex(30, 20)

print (repr(t))

"""**ÁRVORE BINÁRIA**"""

#SELF - Referência ao próprio objeto; NONE - sem valor inicial (não tem métodos)

class NodoArvore:
    def __init__(self, chave=None, esquerda=None, direita=None):
        self.chave = chave
        self.esquerda = esquerda
        self.direita = direita

    def __repr__(self):
        return '%s <- %s -> %s' % (self.esquerda and self.esquerda.chave,
                                    self.chave,
                                    self.direita and self.direita.chave)

x=2 and 2, 3, 5 and 5
print(repr(x))

#implementação de uma árvore binária

raiz = NodoArvore(100)
raiz.esquerda = NodoArvore(90)
raiz.direita  = NodoArvore(200)
print("Árvore: ", raiz)

#m = NodoArvore(3)
#m.esquerda = NodoArvore(1)
#m.direita  = NodoArvore(5)

#print (repr(m))

"""**CAMINHAMENTO ÁRVORE BINÁRIA**"""

raiz = NodoArvore(40)

raiz.esquerda = NodoArvore(20)
raiz.direita  = NodoArvore(60)

#Abertura da Árvore

raiz.direita.esquerda  = NodoArvore(50) #à esquerda da direita
raiz.direita.direita   = NodoArvore(70) #à direita da direita
raiz.esquerda.esquerda = NodoArvore(10) #à esquerda da esquerda
raiz.esquerda.direita  = NodoArvore(30) #à direita da esquerda

print(raiz)

"""**IMPLEMENTAÇÃO DO CAMINHAMENTO EM ORDEM**"""

def em_ordem(raiz):
    if not raiz:
        return

    # Visita filho da esquerda.
    em_ordem(raiz.esquerda)

    # Visita nodo corrente.
    print(raiz.chave),

    # Visita filho da direita.
    em_ordem(raiz.direita)

em_ordem(raiz)

"""ÁRVORE

"""

class Vertice:
  # Atributos ------------------------------------------------------------------
  __pai               = None
  __filho_a_esquerda  = None
  __filho_a_direita   = None
  __chave             = 0
  # ----------------------------------------------------------------------------

  # Construtor -----------------------------------------------------------------
  def __init__(self, chave, pai = None, filho_esquerda = None, filho_direita = None):
    self.set_pai(pai)
    self.set_filho_esquerda(filho_esquerda)
    self.set_filho_direita(filho_direita)
    self.set_chave(chave)
  # ----------------------------------------------------------------------------

  # Métodos de configuração ----------------------------------------------------
  def set_pai(self, pai):
    self.__pai = pai

  def set_filho_esquerda(self, filho_esquerda):
    self.__filho_a_esquerda = filho_esquerda

  def set_filho_direita(self, filho_direita):
    self.__filho_a_direita = filho_direita

  def set_chave(self, chave):
    self.__chave = chave
  # ----------------------------------------------------------------------------

  # Métodos de retorno ---------------------------------------------------------
  def get_pai(self):
    return self.__pai

  def get_filho_esquerda(self):
    return self.__filho_a_esquerda

  def get_filho_direita(self):
    return self.__filho_a_direita

  def get_chave(self):
    return self.__chave

"""**ÁRVORE AVL**"""

#Árvore AVL em Python


class No:
    def __init__(self, data):
        self.data = data
        self.setaFilhos(None, None)

    def setaFilhos(self, esquerda, direita):
        self.esquerda = esquerda
        self.direita = direita

    def balanco(self):
        prof_esq = 0
        if self.esquerda:
            prof_esq = self.esquerda.profundidade()
        prof_dir = 0
        if self.direita:
            prof_dir = self.direita.profundidade()
        return prof_esq - prof_dir

    def profundidade(self):
        prof_esq = 0
        if self.esquerda:
            prof_esq = self.esquerda.profundidade()
        prof_dir = 0
        if self.direita:
            prof_dir = self.direita.profundidade()
        return 1 + max(prof_esq, prof_dir)

    def rotacaoEsquerda(self):
        self.data, self.direita.data = self.direita.data, self.data
        old_esquerda = self.esquerda
        self.setaFilhos(self.direita, self.direita.direita)
        self.esquerda.setaFilhos(old_esquerda, self.esquerda.esquerda)

    def rotacaoDireita(self):
        self.data, self.esquerda.data = self.esquerda.data, self.data
        old_direita = self.direita
        self.setaFilhos(self.esquerda.esquerda, self.esquerda)
        self.direita.setaFilhos(self.direita.direita, old_direita)

    def rotacaoEsquerdaDireita(self):
        self.esquerda.rotacaoEsquerda()
        self.rotacaoDireita()

    def rotacaoDireitaEsquerda(self):
        self.direita.rotacaoDireita()
        self.rotacaoEsquerda()

    def executaBalanco(self):
        bal = self.balanco()
        if bal > 1:
            if self.esquerda.balanco() > 0:
                self.rotacaoDireita()
            else:
                self.rotacaoEsquerdaDireita()
        elif bal < -1:
            if self.direita.balanco() < 0:
                self.rotacaoEsquerda()
            else:
                self.rotacaoDireitaEsquerda()

    def insere(self, data):
        if data <= self.data:
            if not self.esquerda:
                self.esquerda = No(data)
            else:
                self.esquerda.insere(data)
        else:
            if not self.direita:
                self.direita = No(data)
            else:
                self.direita.insere(data)
        self.executaBalanco()

    def imprimeArvore(self, indent = 0):
        print (" " * indent + str(self.data))
        if self.esquerda:
            self.esquerda.imprimeArvore(indent + 2)
        if self.direita:
            self.direita.imprimeArvore(indent + 2)

"""**ÁRVORE RUBRO NEGRA**"""

BLACK = True
RED   = False

class RBTree:

    def __init__(self):
        self.root = None


    def __str__(self):
        return self.printTree(self.root)

    def printTree(self, node):
        str = ''
        if node.left is not None:
            str += self.printTree(node.left)

        str += node.__str__() + '\n'

        if node.right is not None:
            str += self.printTree(node.right)

        return str


    def insert(self, item, key, node=None):
        if node is None:
            node = self.root

        # se a arvore não estiver vazia #
        if node is not None:

            # se for folha #
            if node.left is None and node.right is None:

                # cria um novo nó #
                newNode = RBTreeNode(item, key, parent=node)

                # define se é filho direito ou esquerdo #
                if key >= node.key:
                    node.right = newNode
                else:
                    node.left = newNode

                self.corrigir(newNode)
                return True

            # se tiver filho direito #
            if node.right != None:

                # compara o valor das chaves #
                if key >= node.key:
                    self.insert(item, key, node.right)

            # se tiver filho esquerdo #
            if node.left != None:

                # compara o valor das chaves #
                if key < node.key:
                    self.insert(item, key, node.left)





        # se a arvore estiver vazia #
        else:
                # cria um novo nó #
                newNode = RBTreeNode(item, key, parent=None)

                self.root = newNode
                self.corrigir(newNode)
                return True


    def corrigir(self, node):
        # caso 1 #
        if node.parent is None:
            node.color = BLACK

        # caso 2 #
        else:
            avo = node.avo()
            tio = node.tio()
            pai = node.parent

            if tio != None and tio.color == RED:
                pai.color = BLACK
                avo.color = RED
                tio.color = BLACK

                self.corrigir(avo)

            # caso 3 #
            else:

                # subcaso 1 #

                # Caso o nó inserido seja filho esquerdo e o pai do nó também seja filho esquerdo

                if avo is not None:
                    if avo.left == pai and node == pai.left:

                        # se a cor do avô for preto e do pai for vermelho
                        if avo.color == BLACK and pai.color == RED:

                            # recolore o pai e o avô
                            pai.recolorir()
                            avo.recolorir()

                            # faz-se uma rotação a direita
                            if avo.parent is not None:
                                if avo.parent.left == avo:
                                    avo.parent.left = pai.rotacaoDireita()
                                else:
                                    avo.parent.right = pai.rotacaoDireita()
                            else:
                                self.root = pai.rotacaoEsquerda()


                    # subcaso 2 #

                    # Caso o nó inserido seja filho direito e o pai do nó também seja filho direito
                    elif avo.right == pai and node == pai.right:

                        # se a cor do avô for preto e do pai for vermelho
                        if avo.color == BLACK and pai.color == RED:

                            # recolore o pai e o avô
                            pai.recolorir()
                            avo.recolorir()

                            # faz-se uma rotação a esquerda
                            if avo.parent is not None:
                                if avo.parent.left == avo:
                                    avo.parent.left = pai.rotacaoEsquerda()
                                else:
                                    avo.parent.right = pai.rotacaoEsquerda()
                            else:
                                self.root = pai.rotacaoEsquerda()

                    # subcaso 3 #

                    # Caso o nó inserido seja filho esquedro e o pai seja filho direito
                    elif avo.right == pai and node == pai.left:

                        # se a cor do avô for preto e do pai for vermelho
                        if avo.color == BLACK and pai.color == RED:

                            # recolore o pai e o avô
                            # pai.recolorir()
                            # avo.recolorir()

                            # realiza-se uma rotação simples a direita
                            avo.right = node.rotacaoDireita()

                            if avo.parent is not None:
                                if avo.parent.left == avo:
                                    avo.parent.left = pai.rotacaoEsquerda()
                                else:
                                    avo.parent.right = pai.rotacaoEsquerda()
                            else:
                                self.root = pai.rotacaoEsquerda()

                    # subcaso 4 #

                    # Caso o nó inserido seja filho esquedro e o pai seja filho direito
                    elif avo.left == pai and node == pai.right:

                        # se a cor do avô for preto e do pai for vermelho
                        if avo.color == BLACK and pai.color == RED:

                            # recolore o pai e o avô
                            # pai.recolorir()
                            # avo.recolorir()

                            # realiza-se uma rotação simples a esqueda
                            avo.left = node.rotacaoEsquerda()

                            if avo.parent is not None:
                                if avo.parent.left == avo:
                                    avo.parent.left = pai.rotacaoDireita()
                                else:
                                    avo.parent.right = pai.rotacaoDireita()
                            else:
                                self.root = pai.rotacaoDireita()
                self.corrigir(pai)



import numpy as np
import matplotlib.pyplot as plt

# Dados de entrada
X = np.array([[0, 1], [1, 1], [1, 0], [0, 0]])
y = np.array([1, 0, 0, 0])

# Parâmetros do perceptron
w1 = -1
w2 = -1
b = 1.5

# Função de ativação
def step_function(u):
    return 1 if u >= 0 else 0

# Fronteira de decisão
x1 = np.linspace(-0.2, 1.2)
x2 = -(w1*x1 + b)/w2

# Gráfico
plt.scatter(X[:,0], X[:,1], c=y)
plt.plot(x1, x2)
plt.xlim(-0.2, 1.2)
plt.ylim(-0.2, 1.2)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Valores dos parâmetros do perceptron
w1 = -1
w2 = 1
b = 0.5

# Definição da função da fronteira de decisão
def decision_boundary(x):
    return -(w1*x + b)/w2

# Dados para plotar os pontos
x1 = [0, 1, 1, 0]
x2 = [1, 1, 0, 0]
y = [0, 0, 0, 1]

# Plotagem dos pontos
plt.scatter(x1[:3], x2[:3], color='blue', label='Classe 0')
plt.scatter(x1[3:], x2[3:], color='red', label='Classe 1')
plt.scatter([0], [0], marker='x', color='green', s=100, label='Ponto a classificar')

# Plotagem da fronteira de decisão
x_range = np.linspace(-0.2, 1.2, 100)
plt.plot(x_range, decision_boundary(x_range), color='black', linestyle='--', label='Fronteira de decisão')

# Configurações adicionais do gráfico
plt.xlim([-0.2, 1.2])
plt.ylim([-0.2, 1.2])
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Definição dos dados
x1 = [0, 1, 1]
x2 = [1, 1, 0]
y = [1, 1, 1, 0]

# Definição dos parâmetros do perceptron
w1 = 1
w2 = -1
b = -0.5

# Cálculo da fronteira de decisão
x_min, x_max = np.min(x1) - 1, np.max(x1) + 1
y_min, y_max = np.min(x2) - 1, np.max(x2) + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
                     np.arange(y_min, y_max, 0.01))
Z = np.sign(w1*xx + w2*yy + b)
Z = np.clip(Z, 0, 1)

# Plot dos dados e da fronteira de decisão
plt.figure(figsize=(6, 6))
plt.scatter(x1, x2, c=y, cmap='jet')
plt.contourf(xx, yy, Z, alpha=0.2, cmap='jet')
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('Perceptron para 3 círculos e um x')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Definição dos dados
x1 = [0, 1, 1]
x2 = [1, 1, 0]
y = [1, 1, 1, 0]

# Definição dos parâmetros do perceptron
w1 = -1
w2 = -1
b = 2

# Cálculo da fronteira de decisão
x_min, x_max = np.min(x1) - 1, np.max(x1) + 1
y_min, y_max = np.min(x2) - 1, np.max(x2) + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
                     np.arange(y_min, y_max, 0.01))
Z = np.sign(w1*xx + w2*yy + b)
Z = np.clip(Z, 0, 1)

# Plot dos dados e da fronteira de decisão
plt.figure(figsize=(6, 6))
plt.scatter(x1, x2, c=y, cmap='jet')
plt.contourf(xx, yy, Z, alpha=0.2, cmap='jet')
plt.plot([0, 1], [2, 1], 'k-', lw=2)
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('Perceptron para 3 círculos e um x')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Definição dos dados
x1 = [0, 1, 1]
x2 = [1, 1, 0]
y = [1, 1, 1, 0]

# Definição dos parâmetros do perceptron
w1 = -1
w2 = 1
b = 0

# Cálculo da fronteira de decisão
x_min, x_max = np.min(x1) - 1, np.max(x1) + 1
y_min, y_max = np.min(x2) - 1, np.max(x2) + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01),
                     np.arange(y_min, y_max, 0.01))
Z = np.sign(w1*xx + w2*yy + b)
Z = np.clip(Z, 0, 1)

# Plot dos dados e da fronteira de decisão
plt.figure(figsize=(6, 6))
plt.scatter(x1, x2, c=y, cmap='jet')
plt.contourf(xx, yy, Z, alpha=0.2, cmap='jet')
plt.plot([0, 1], [1, 0], 'k-', lw=2)
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('Perceptron para 3 círculos e um x')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Dados dos pontos
x1 = [0, 1, 1, 0]
x2 = [1, 1, 0, 0]
y = [1, 1, 1, 2]

# Pesos sinápticos e bias
w1 = 1
w2 = 1
b = -1

# Fronteira de decisão
m = -(w1/w2)
c = b/w2
x = np.linspace(-0.5, 1.5)
y = m*x + c

# Plot
plt.scatter(x1[:3], x2[:3], color='blue')
plt.scatter(x1[3:], x2[3:], color='red')
plt.plot(x, y, color='black')
plt.xlim(-0.5, 1.5)
plt.ylim(-0.5, 1.5)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# dados de entrada
X = np.array([[0,1], [1,1], [1,0], [0,0]])
y = np.array([1, 1, 1, 0])

# pesos e bias
w = np.array([1, 1])
b = -1

# função de ativação
def step_function(x):
    return np.where(x>=0, 1, 0)

# fronteira de decisão
x1_values = np.linspace(-0.5, 1.5, 100)
x2_values = -(w[0]*x1_values + b)/w[1]

# plot dos dados e da fronteira de decisão
plt.figure()
plt.scatter(X[:,0], X[:,1], c=y)
plt.plot(x1_values, x2_values, 'r--')
plt.xlim(-0.5, 1.5)
plt.ylim(-0.5, 1.5)
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('Fronteira de Decisão do Perceptron')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# dados de entrada
x1 = np.array([0, 1, 1, 0])
x2 = np.array([1, 1, 0, 0])
y = np.array([1, 1, 1, 2])

# plotando os dados
fig, ax = plt.subplots(figsize=(6,6))
ax.scatter(x1[y==1], x2[y==1], color='red', marker='o', label='Classe 1')
ax.scatter(x1[y==2], x2[y==2], color='blue', marker='x', label='Classe 2')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
ax.legend()

# plotando a fronteira de decisão
x = np.linspace(-0.5, 1.5)
y = -x + 1
plt.plot(x, y, '-g', label='Fronteira de Decisão')
plt.ylim([-0.5, 1.5])
plt.xlim([-0.5, 1.5])
plt.legend(loc='best')

plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Definindo as coordenadas dos pontos
x1 = [0, 1, 1, 0]
x2 = [1, 1, 0, 0]

# Definindo as coordenadas do ponto x
x1_x = [0.5]
x2_x = [0.5]

# Gerando valores para x1 no intervalo [-0.2, 1]
x1_line = np.linspace(-0.2, 1, 100)

# Calculando os valores correspondentes de x2
x2_line = -x1_line + 1

# Plotando os pontos dos círculos e do x
plt.plot(x1[:3], x2[:3], 'o', markersize=10, label='Classe 1')
plt.plot(x1[3], x2[3], 'x', markersize=10, label='Classe 2')
plt.plot(x1_x, x2_x, 'x', markersize=10, label='Ponto x')

# Plotando a reta 𝑥1 + 𝑥2 - 1 = 0
plt.plot(x1_line, x2_line, label='Fronteira de decisão')

# Configurando o gráfico
plt.xlim(-0.2, 1)
plt.ylim(-0.2, 1)
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('Gráfico da fronteira de decisão')
plt.legend()

# Exibindo o gráfico
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# define a função do perceptron
def perceptron(x1, x2):
    return np.heaviside(x1 + x2 - 1.5, 1)

# define os pontos das duas classes
x1_circulos = [0, 1]
x2_circulos = [0, 1]
x1_x = [0]
x2_x = [1]

# define a grade de pontos para plotar a fronteira de decisão
x1_grid, x2_grid = np.meshgrid(np.linspace(-0.2, 1, 100), np.linspace(-0.2, 1, 100))
y_grid = perceptron(x1_grid, x2_grid)

# plota a fronteira de decisão e os pontos das duas classes
plt.contourf(x1_grid, x2_grid, y_grid, levels=[-1, 0, 1], colors=['white', 'gray'])
plt.plot(x1_circulos, x2_circulos, 'o', color='red', label='Classe 1')
plt.plot(x1_x, x2_x, 'x', color='blue', label='Classe 2')

# define os limites dos eixos x e y
plt.xlim(-0.2, 1)
plt.ylim(-0.2, 1)

# adiciona legenda e título ao gráfico
plt.legend(loc='upper left')
plt.title('Fronteira de Decisão do Perceptron')
plt.xlabel('x1')
plt.ylabel('x2')

# exibe o gráfico
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# definir a equação da reta
w1, w2, b = 1/2, 1/2, -1/2
x1 = np.linspace(-0.2, 1, 100)
x2 = -w1/w2 * x1 + (w1+w2)/w2

# plotar os pontos
plt.scatter([0, 1], [1, 0], c=['r', 'b'], label=['Classe 1', 'Classe 2'])

# plotar a reta
plt.plot(x1, x2, 'g', label='Fronteira de decisão')

plt.xlim(-0.2, 1)
plt.ylim(-0.2, 1)
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
plt.show()
